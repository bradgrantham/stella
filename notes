audio implementation
    hook up SDL audio
        Coleco emulator did "void generate_audio(clk_t clk, audio_flush_func stereo_audio_flush)", so need to either walk to next clock or directly calculate it
        Maybe should walk samples in a buffer at CLK time for TIA audio clock...
            resample to Platform rate
    waveform is -128 for 0 and to 127 for 1, scaled by X/16 for volume
    uint8_t advance_channel_clock(uint8_t AUDV, uint8_t AUDF, uint8_t AUDC, int& counter uint16_t& bitstream)
        // Does writing new AUDF reset the counter?  Or is it only used to reload the counter?
        if(counter > 0) {
            counter--;
        } else {
            counter = AUDF;
            // Do polys
        }

        // Do polynomial based on AUDC
        int noise_length; // 4, 5, 9
        int z; // 0 or 1
        switch(AUDC) {
            case 0xB:
            case 0x0:
            {
                // Does this actually shift 1 in, or does it just force the output to 1?
                z = 1;
                noise_length = 4;
                break;
            }
            case 0x1:
            {
                noise_length = 4;
                z = (bitstream >> 6) ^ (bitstream >> 5) & 0x1;
                break;
            }
            case 0x2:
                break;
            case 0x3:
                break;
            case 0x4:
                break;
            case 0x5:
                break;
            case 0x6:
                break;
                break;
            case 0x8:
            {
                noise_length = 9;
                z = (bitstream >> 4) ^ (bitstream >> 0) & 0x1;
                break;
            case 0x7:
            case 0x9:
            {
                noise_length = 5;
                z = (bitstream >> 6) ^ (bitstream >> 4) & 0x1;
                break;
            }
            case 0xA:
                break;
            case 0xC:
                break;
            case 0xD:
                break;
            case 0xE:
                break;
            case 0xF:
                break;
        }
        int noise_bit = 9 - noise_length;
        int sound_bit = (bitstream >> noise_bit) & 0x01;

        // Does this need to be applied using an additional counter?
        bitstream = (z << 8) | (bitstream >> 1);

        return 128 + (sound_bit ? -128 : 127 ) * 15 / AUDV;

    advance_audio_clock() function walks audio clock
        uint8_t level = advance_channel_clock(volume, counter, divider, control) // for each channel
        for every platform sampling clock crossing, emit platform samples for the two channels, flush if full
    add to advance_on_clock()
        advance_audio_clock()
sprites wrong place - everything and multisprite3.a26
sprites jitter - Pac-Man
